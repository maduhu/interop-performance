# JMeter for load and scenario testing

Contains an initial attempt at providing performance and functional tests for Level One assets.

### Setup

You will need [Apache JMeter 3.X](http://jmeter.apache.org/download_jmeter.cgi) to load these files.

1.  Download the appropriate archive for your operating system and expand it.
2.   Download [jmeter-plugin-manager](https://jmeter-plugins.org/get/) and place it in the `lib/ext` folder under the path you extracted jmeter
3.  Navigate to the `/bin` folder under the path you extracted jmeter
4.  Start JMeter by executing `jmeter.bat` or `jmeter.sh` depending on your os
5.  Navigate to Options Menu -> Plugin Manager -> Available Plugins (middle tab)
6.  Select `JMeter Plugins JSON` and then click `Apply Changes and Restart JMeter`

### Test Configuration

The test is driven by several components
- environment configuration
- test case data
- desired throughput
- number of concurrent clients

#### Environment Configuration:

User variables required to configure the test are located in the `User Paramerters` element as shown below

![User Parameters](./previous/media/user_params.jpg "User Params")

In this section you should configure the following attributes:

| attribute | description |
| --------- | ----------- |
| ledgerHost | the host name the test should connect to |
| ledgerPort | the port |
| expiresAt | what data for expresAt should be included.  Some date in the future. |
| ledgerUrl | by default its being built by host and port but you can change it here.  these goes inside some of the request messages |
| authorization | the value to be included in the Authorization header element.  This value is correct for admin / foo.  This is a temporary hack. | 

#### Test Case Configuration:

This test loads test cases from a csv file.  You will need to either copy the sample file located here into your `jmeter bin` directory or edit this element and include the path to the file.  The file contains the following data.

![CSV Config](./previous/media/test_data_config.jpg "CSV Config")

fromAccountName, toAccountName, transferAmount

example:

```
alice,bob,50
bob,alice,100
```

Each line in the file will cause be run by a client thread.  When all of the lines have been executed the test will loop back to the beginning. This behavior can be changed.

Note that since this is a test that is intended to be run multiple times it does not create the accounts first.  You will need to create accounts in your ledger with sufficient balances to sustain the test.  When there are insufficnet funds in a ledger you will start seeing errors pop up in the results table.

#### Number of Concurrent Clients:

A `thread group` configures how many client threads should be used, how long they should take to ramp up to full load, and how many iterations of the test they should execute.

![Thread Group Config](./previous/media/thread_group_config.jpg "Thread Group Config")

In this example we have 5 client threads ramping up over a 1 second window.  They will loop forever.  If the test receives an error it will continue to run.

As the number of client threads are increased throughput will increase to a point.  There will be a point where throughput will continue to increase but per call latency will also start to climb.  This is generally around the point where you cross over the number of threads allocated to the receiving thread pool on the service you are calling against.  For example the default number of threads allocated to a http listener in mule is 16.  As we increase client threads up to 16 throughput will steadily increase.  Past 16 latency starts to climb because each client thread has to wait for some number of server side threads to complete before its request can be servied.  This can be good to a point because we are optimizing out part of the round trip latency between the computer making the request and the server servicing it.  The time for the request to get there becomes free from the perspective of overall throughput.

#### Throughput Configuration

The `constant throughput timer` constrains the amount of load generated by the client threads on the target system.  It will constrain client connections so that they do not exceed the specified number of requests per minute.  Note that these are total requests generated.  The test case contains several requests per test iteration.

![Throughput Config](./previous/media/throughput_config.jpg "Throughput Config")

#### Executing the Test

To start the test select `Run -> Start` or click the ![start](./previous/media/start.jpg) button in the center of the toolbar.  To stop the test select `Run -> stop` or select the ![stop](./previous/media/stop.jpg) button.  To clear resuts from previous test runs select the ![clear](./previous/media/clear.jpg) icon.

#### Viewing Results

Results are being collected into a table and a graph.  Other listeners can be configured.

![Results Table](./previous/media/results_table.jpg "Results Table")

![Results Graph](./previous/media/results_graph.jpg "Results Graph")

#### Debugging

If you are getting nothing but errors you can right click on the "Save Responses to a file" element near the bottom and choose enable.  It will save the response from each step into its own file.  You can also click on the `Test Plan` element at the top and select `Functional Test Mode`.  This will cause JMeter to store the results of each call into a file.  When debugging I recomment going into the `Thread Group` configuration and setting client threads to 1, unchecking forever and selecting 1 for the number of test iterations to execute.  For this test the thread group element is the second one from the top and is called `ILP Ledger - multi-user performance test`

#### Extending / Reusing

These basic tests can be used as the basis for testing any of our other rest based api's.  There are many other connectors available other than rest as well.

**JSON Path Extractor:**
![JSON Path Extract](./previous/media/json_path_extractor.jpg "JSON Path Extract")

This element shows extracting data from the response of a call to lookup an account.  The `id` field contains the full path of the ledger account and is used in the subsequent call to construct the transfer request.  The data is coming from response text, from the element named `id` in the root of the response object, and is being placed in a variable called fromLedgerPath.  This will be referenced later is `${fromLedgerPath}`

**JSON Path Assertion:**
![Assertion Example](./previous/media/assertion_example.jpg "Assertion Example")

This element shows reading in the value `state` from the root of the response payload and asserting that it equals `executed`.  The response code assertion further down checks to see if the status was 200.
